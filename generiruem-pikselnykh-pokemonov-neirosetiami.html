<!DOCTYPE html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>    Генерируем пиксельных покемонов нейросетями
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
            <link href="https://fonts.googleapis.com/css?family=PT+Serif:400,400i,700,700i&amp;display=swap" rel="stylesheet">
        <link rel="stylesheet" href="/theme/css/main.css">
        <link rel="stylesheet" href="/theme/css/stars.css">
        <link rel="stylesheet" href="/theme/css/gray.css">

    <link rel="stylesheet" href="/theme/css/blog.css">
    <link rel="stylesheet" href="/theme/css/github.css">
        <!-- <script src="/theme/js/vendor/modernizr-2.6.2.min.js"></script> -->
        <link rel="shortcut icon" href="/images/favicon.png" />

    </head>
    <body class="">
        <div id="page" class="site palette-yellow">
      
      <header id="masthead" class="site-header bg--loaded">

        <div id="header-bg" class="site-header-bg" style="background-image:url('/images/DATAscience.png')">
          </div>
        <div class="site-header-scroll">
          <div class="site-header-inside">
            <div class="site-header-vertical">
              <div class="site-branding">
                <p class="site-logo">

                </p>
                <p class="site-description">Stmirage projects page</p>
              </div>
              <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">

                <div class="site-nav-wrap">
                  <div class="site-nav-inside">
                    <ul class="menu">
                      <li class="menu-item current-menu-item">
                        <a href="/">Главная</a>
                      </li>
                      <li class="menu-item">
                        <a href="/pages/kontakty">Контакты</a>
                      </li>
                      <li class="menu-item">
                        <a href="/pages/vse-proekty">Все проекты</a>
                      </li>
                    </ul>

                  </div>
                </div>
              </nav>

              <button id="menu-toggle" class="menu-toggle">
                <span class="screen-reader-text">Menu</span>
                <span class="icon-menu" aria-hidden="true"></span>
              </button>
            </div>
          </div>
        </div>
      </header>


<!--

        <footer id="colophon" class="site-footer inner">
          <div class="site-footer-inside">
            <span class="copyright">Опубликовано с удовольствием 2019-2020</span>
          </div>
        </footer>  
-->





        <div id="content" class="site-content">
        <main id="main" class="site-main inner">

    <div id="post-container">
                <article class="post-entry">
                    <header class="entry-header">
                        <time>
                            31.03.2021
                        </time>
                        <a href="/generiruem-pikselnykh-pokemonov-neirosetiami.html" rel="bookmark"><h1>Генерируем пиксельных покемонов нейросетями</h1></a>
                    </header>

                    <section class="post-content">
                        <p>Создание покемонов имело скорее развлекательный характер, но возникло из другого диалога. В конце мы перейдем на более серьёзные темы.</p>
<blockquote>
<p>"Мудрый человек слушает смысл, а дурак ― только шум."</p>
<p>-- <cite>Николас Талеб. «Одураченные случайностью. Скрытая роль шанса на рынках и в жизни»</cite></p>
</blockquote>
<h2>Предысловие</h2>
<p>Заметка служит иллюстрацией к разговору, который никак не касался ни покемонов, ни генерации изображений. К этому разговору мы вернемся в конце, а пока поставим себе задачу сделать простую нейросеть, которая создаёт новых покемонов.</p>
<p>Часто в руководствах для новичков по нейросетях не указывают некоторые важные моменты, которые будут очень влиять на итоговый результат. Мы сначала нарушим часть из них, чтобы увидеть почему это важно. После этого потом будем соблюдать, чтобы получить хороший результат.</p>
<h2>Датасет</h2>
<p>За основу возьме 898 изображений пиксельных покемонов, взятых с <a href="{https://pokemondb.net/sprites}">сайта с описанием всех покемонов</a>.</p>
<p>Датасет очень небольшой. Но хуже,что покемоны имеют между собой очень мало общего.</p>
<p>Это уже два нарушения. Если с размером датасета всё понятно, то похожесть изображений часто игнорируется. Берется какой-нибудь датасет человеческих лиц или грузовиков, у которых много общего.</p>
<p>Картинка покемона размером 42х56 пикселей в RGB цвете.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok1.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Типичный представитель</em></td>
</tr>
</tbody>
</table>
<h2>Простой автоэнкодер</h2>
<p>Все проекты по генерации чего-либо я начинаю с простого автоэнкодера. Как он работает, можно посмотреть в <a href="/analiz-rynka-aktsii-moskovskoi-birzhi-chast-1.html">статье про финансы.</a>.</p>
<p>Это необязательный шаг, но так легче понять насколько хорошо кодируется изображение, с какими особенностями придётся столкнуться.</p>
<p>На вход подаётся изображение покемона. Автоэнкодер будет пытаться сжать изображение примерно в 7 раз, а после восстановить из сжатого состояния этого того же покемона.</p>
<p>Рисовать архитектуру я не буду. Иногда буду оставлять основные цифры по числу слоёв.</p>
<p>В данной сети будет 3 слоя: входной, выходной и скрытый в 1024 нейрона.</p>
<p>После начала тренировки, изображение постепенно восстанавливается.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok2.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Оригинальные и раскодированные изображения</em></td>
</tr>
</tbody>
</table>
<p>Отметим количество шума. Для семикратного сжатия выглядит неплохо.</p>
<p>Сделаем всё тоже самое в серых тонах и уменьшим сжатие. Оставим внутреннее количество слоёв без изменения. Получится 2х кратное сжатие.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok3.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Оригинальные и раскодированные изображения</em></td>
</tr>
</tbody>
</table>
<p>Практически оригинал. Работает гораздо быстрее.</p>
<h2>Вариационный автоэнкодер</h2>
<p>Одним из методов для генерации изображений, который рекомендуют почти в каждом руководстве, является вариационным автоэнкодер.</p>
<p>В двух словах - мы берем случайно из скрытого слоя енкодера случайное значение из некоего распределения и декодируем его обратно в изображение.</p>
<p>Попробуем уменьшить число скрытых слоёв и взять несколько изображений, расположенных "рядом" в пространстве скрытого слоя.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok4.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Срез пространства полученных изображений по порядку. Гигантский зверь сжимается в шар.</em></td>
</tr>
</tbody>
</table>
<p>Увиденные нами существа из других измерений требуют расшифровки. Нейросеть недообучилась и тут есть ряд причин.</p>
<ol>
<li>У нас очень мало данных.</li>
<li>Вторая причина гораздо более важная. Вариацинные энкодеры хорошо работают, если между одним классом изображения и другим есть некоторые промежуточные состояния. </li>
</ol>
<p>Для того, чтобы лучше проиллюстрировать эту идею, уберем цвет из сети и увеличим число скрытых слоёв.</p>
<p>Так вариационный энкодер пытается получить нового покемона. Он ничего не придумывает, не комбинирует элементы, он пытается по плотности пикселей взять что-то среднее.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok6.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Один из гибридов внутри скрытых слоёв</em></td>
</tr>
</tbody>
</table>
<h3>Почему этот тип сети не сработал?</h3>
<p>В каждом туториале в качестве примера их успешной работы показывают, как правило, один из двух датасетов: рукописные цифры из набора MNIST или лица людей. Между изображениями цифр 3 и 9 можно себе представить промежуточную размытую закорючку. Между двумя лицами также можно придумать размытое пограничное состояние. Но в нашем случае 2 горстки пикселей не имеют общих моментов.</p>
<p>Сеть может лишь определить размеры среднего покемона, но выбирая каждый пиксель, она путается.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok5.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Срез пространства полученных изображений по порядку. Гигантский зверь сжимается в шар.</em></td>
</tr>
</tbody>
</table>
<p>Для того, чтобы поменьше расстраиваться, посмотрим на очередной набор химер.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok7.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Прекрасный мир между одни покемоном и другим</em></td>
</tr>
</tbody>
</table>
<h2>DC-GAN</h2>
<p>Другой архитектурой, которую часто без дополнительных описаний выкладывают для генерации изображений является GAN.</p>
<p>В двух словах: одна нейроеть учится генерировать изображения, вторая отличать целевые изображения от нецелевых. Постепенно первая учится создаать реалистичные изображения.</p>
<h3>Первая попытка: бактериальный мир</h3>
<p>У сети огромное число параметров, которые необходимо аккуратно подбирать, причем держа в голове какой за что отвечает.</p>
<p>Вот, например, так выглядел результат первой попытки. Как видно, мы еще очень далеки от того, что можно хотя бы опознать как существо.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok8.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Прекрасный мир покемоно бактерии</em></td>
</tr>
</tbody>
</table>
<h3>Вторая попытка: мир глаз</h3>
<p>Сеть училась очень медленно. Сейчас мы начнём правильно настраивать датасет, чтобы с ним можно было работать.</p>
<ul>
<li>Использовать видеокарту для вычислений. TensorFlow перестал дружить с моей видекартой, я полностью переписал всё на pytorch.</li>
<li>Изменить параметры и число слоёв. Это очень кропотливый процесс. Сердцем генератора является тип слоя Conv2dTranspose, ключевым параметром которого является размер ядра свёртки. Слишком большой или малый он будет неверно реконструировать изображения, выделяя или слишком мелкие элементы, или наоборот будет запоминать почти всего покемона сразу.</li>
<li>Искуственно увеличил датасет путём смещения изображений в разные стороны, отзеркаливания изображения и т.д.</li>
</ul>
<p>Для начала сеть научилась находить глаза и клювы.</p>
<p>Среди картинок столь малого размера есть несколько видов того, что можно назвать глазом:</p>
<ul>
<li>белый круг с точкой в центре в самом видном месте покемона.</li>
<li>черная точка-бусинка на однотонном цвете.</li>
</ul>
<p>Покемоны крайне редко выходили совсем однотонными, так что со вторым типомы выходило похуже. Казалось, что глаза некоторым покемонам дорисовывает воображение.</p>
<p>А вот глаз первого типа стал настолько узнаваем, что не пропадал даже при повторах всего обучения с нуля.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok9.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>белый круг с точкой в центре это именно обощенный крупный глаз, взятый у некоторых представителей вида. у правого верхнего эту часть размыло. У нижних особей красные точки около глаза, это именно клюв, взятый у одного и того же покемона</em></td>
</tr>
</tbody>
</table>
<p>Как видно на рисунках, нейросеть отлично понимает редкие детали и произвольно добавляет крылышки (верхний ряд - трое справа - это мутации одного и того же покемона)</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok10.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Иногда сеть достаточно смешно запутывается. Это существо состоит просто из трёх глаз</em></td>
</tr>
</tbody>
</table>
<p>Шума тоже хватает. Сеть ещё требует настройки. Я постоянно лавировал между тем, чтобы в детализации хорошо получались мелкие детали, но за это пришлось жертвовать тем, что сеть не понимала, что надо красить покемонов в 1 цвет. Я думаю, что знаю решение, но на этот раз уже тюнинговать не буду. Покемоны не самоцель.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok11.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>я вижу здесь существ, но это может и быть плодом моего воображения</em></td>
</tr>
</tbody>
</table>
<p>Началось получаться то, что нужно.</p>
<h3>Бонус</h3>
<p>Немного ошибся с цветами, когда делал черно-белый вариант. В какой-то момент стали получаться черные сгустки темномы с глазами. Не могу не поделиться.</p>
<table>
<thead>
<tr>
<th align="center"><img alt="Покемон" src="/images/pok12.png"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Когда знаешь происхождение некоторых элементов, становится страшно. Потому что слева, это облако состоящее из глаз</em></td>
</tr>
</tbody>
</table>
<h3>Характерные особенности получившихся изображений</h3>
<p>Есть несколько моментов, которые стоит доделать, если потратить немного времени</p>
<ul>
<li>уменьшить шум, написав отдельный шумоподавляющие автоэнкодер</li>
<li>дать больше времени на обучение</li>
<li>еще сильнее улучшить качество датасета поворачивая и масштабируя исходные изображения</li>
</ul>
<h2>Итог</h2>
<p>Итак, мы насмотрелись на покемонов, но эта иллюстрация идеи, не связанной с играми.</p>
<p>В некоторых случаях один друг настойчиво предлагал использовать различные нейросети, чтобы получать большее количество семплов для обучения на маленьких выборках обычных данных — медицинских записях, банковских операциях.</p>
<p>Я скептически смотрю на эту идею. Доработка сети потребовала нескольких часов. Но я смог получать хоть сколько-нибудь адекватные семплы только потому что мой человеческий мозг умеет отличать покемона от непокемона хотя бы в общих понятиях.</p>
<p>Но если дело касается данных, у которых нет образной составляющей, не всегда оверсемплинг можно производить методом без понимания его сути. Ошибиться можно на любой стадии:</p>
<ul>
<li>малый датасет</li>
<li>недостаточное время на обучение</li>
<li>разнородные элементы без общих черт</li>
<li>отсутствие шумоподавления на выходе</li>
</ul>
<p>Вариационные енкодеры упоминаются каждый раз, но без настроек они не видят паттернов.</p>
<p>CNN слои в GAN архитектурах требуют настройки и тюнига.</p>
<p>Но если мы говорим не о 900 картинках с покемонами, то у нас есть способы оценки результата.Но для 900 жульнических банковских операциях без датасета с 100000 честными, какова вероятность, что мы смоделиуем именно то, что нужно? </p>
<p>Для работы с тестовой выборкой вполне допустим SMOT, но иногда просто бывает мало данных, и стоит сосредоточиться на работе с ними через более классические инструменты. </p>
                    </section>
                    <hr/>
                    <aside class="post-meta">
                        <p>Category: <a href="/category/machinelearning.html">MachineLearning</a></p>
                    </aside>
                    <hr/>
                </article>
    </div>
        </main>
        <footer id="colophon" class="site-footer inner">
          <div class="site-footer-inside">
            <span class="copyright">Опубликовано с удовольствием 2019-2020</span>
          </div>
        </footer>
      </div>

        </div>

        <script src="/theme/js/main.js" type="text/javascript"></script>
        <script src="/theme/js/plugins.js" type="text/javascript"></script>
        <!-- Yandex.Metrika counter -->
        <script type="text/javascript" >
           (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
           m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
           (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

           ym(69735988, "init", {
                clickmap:true,
                trackLinks:true,
                accurateTrackBounce:true
           });
        </script>
        <noscript><div><img src="https://mc.yandex.ru/watch/69735988" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
        <!-- /Yandex.Metrika counter -->
    </body>



<!--               

 -->